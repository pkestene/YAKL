cmake_minimum_required(VERSION 3.0)

project(YAKL
  LANGUAGES C CXX Fortran
  HOMEPAGE_URL https://github.com/mrnorman/YAKL/
  VERSION 0.99
  DESCRIPTION "A Simple C++ Framework for Performance Portability and Fortran Code Porting")

# gnu compatibility,
# see https://cmake.org/cmake/help/latest/module/GNUInstallDirs.html
include(GNUInstallDirs)

#
# Set default build type
#
if (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
  set(DEFAULT_BUILD_TYPE "RelWithDebInfo")
  message(STATUS "Setting build type to '${DEFAULT_BUILD_TYPE}' as none was specified.")
  set(CMAKE_BUILD_TYPE "${DEFAULT_BUILD_TYPE}" CACHE STRING
    "Choose the type of build, options are: Debug, Release, RelWithDebInfo and MinSizeRel." FORCE)
  # Set the possible values of build type for cmake-gui
  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
    "Debug" "Release" "MinSizeRel" "RelWithDebInfo")
endif ()

if ("${YAKL_ARCH}" STREQUAL "CUDA")
  enable_language(CUDA)
endif()

# cmake options
option(YAKL_VERBOSE "Turn on verbose log messages (default OFF)." OFF)
option(YAKL_VERBOSE_FILE "Turn on verbose log messages dump in file (default OFF)." OFF)
option(YAKL_DEBUG "Turn on error message throwing (default OFF)." OFF)
option(YAKL_HAVE_MPI "Turn on MPI (default OFF)." OFF)
option(YAKL_ENABLE_STREAMS "Turn on streams (default OFF)." OFF)
option(YAKL_AUTO_PROFILE "Turn on (nvtx-based) profiling (default OFF)." OFF)
option(YAKL_AUTO_FENCE "Turn on auto fence (default OFF)." OFF)
option(YAKL_B4B "Force serial computation (default OFF)." OFF)
option(YAKL_MANAGED_MEMORY "Turn on managed memory (default OFF)." OFF)


set(YAKL_CXX_SOURCE src/YAKL.cpp)
set(YAKL_F90_SOURCE src/YAKL_gator_mod.F90)
set(YAKL_SOURCE ${YAKL_CXX_SOURCE} ${YAKL_F90_SOURCE})

if ("${YAKL_ARCH}" STREQUAL "CUDA")
  message(STATUS "** Building YAKL for a CUDA backend **")
elseif ("${YAKL_ARCH}" STREQUAL "HIP")
  message(STATUS "** Building YAKL for a HIP backend **")
elseif ("${YAKL_ARCH}" STREQUAL "OPENMP")
  message(STATUS "** Building YAKL for a CPU OPENMP threading backend **")
elseif ("${YAKL_ARCH}" STREQUAL "OPENMP45")
  message(STATUS "** Building YAKL for an OPENMP offload backend **")
elseif ("${YAKL_ARCH}" STREQUAL "SYCL")
  message(STATUS "** Building YAKL for an SYCL offload backend **")
elseif ("${YAKL_ARCH}" STREQUAL "")
  message(STATUS "** YAKL_ARCH not set. Building YAKL for a serial CPU backend **")
else()
  message(FATAL_ERROR "** YAKL_ARCH set to an invalid backend target: ${YAKL_ARCH} **")
endif()

include(yakl_utils.cmake)

yakl_process_cxx_source_files("${YAKL_CXX_SOURCE}")
message(STATUS "** YAKL is using the following C++ flags: ${YAKL_COMPILER_FLAGS} **")

set_source_files_properties(${YAKL_F90_SOURCE} PROPERTIES COMPILE_FLAGS "${YAKL_F90_FLAGS}")

add_library(yakl STATIC ${YAKL_SOURCE})
if (YAKL_VERBOSE)
  target_compile_definitions(yakl PUBLIC -DYAKL_VERBOSE)
endif()
if (YAKL_VERBOSE_FILE)
  target_compile_definitions(yakl PUBLIC -DYAKL_VERBOSE_FILE)
endif()
if (YAKL_DEBUG)
  target_compile_definitions(yakl PUBLIC -DYAKL_DEBUG)
endif()
if (YAKL_HAVE_MPI)
  target_compile_definitions(yakl PUBLIC -DYAKL_HAVE_MPI)
endif()
if (YAKL_ENABLE_STREAMS)
  target_compile_definitions(yakl PUBLIC -DYAKL_ENABLE_STREAMS)
endif()
if (YAKL_AUTO_PROFILE)
  target_compile_definitions(yakl PUBLIC -DYAKL_AUTO_PROFILE)
endif()
if (YAKL_AUTO_FENCE)
  target_compile_definitions(yakl PUBLIC -DYAKL_AUTO_FENCE)
endif()
if (YAKL_B4B)
  target_compile_definitions(yakl PUBLIC -DYAKL_B4B)
endif()
if (YAKL_MANAGED_MEMORY)
  target_compile_definitions(yakl PUBLIC -DYAKL_MANAGED_MEMORY)
endif()

set_property(TARGET yakl PROPERTY CXX_STANDARD 17)

target_include_directories(yakl PUBLIC
  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src>
  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/external>
  $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>
  $<INSTALL_INTERFACE:include>)

target_include_directories(yakl PUBLIC
  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src/extensions>
  $<INSTALL_INTERFACE:include/extensions>)

if ("${YAKL_ARCH}" STREQUAL "CUDA")
  set_target_properties(yakl PROPERTIES LINKER_LANGUAGE CUDA CUDA_SEPARABLE_COMPILATION OFF CUDA_RESOLVE_DEVICE_SYMBOLS ON)
  target_link_libraries(yakl)
  if(${CMAKE_VERSION} VERSION_GREATER_EQUAL 3.22.0 )
    message("Using CUDAToolkit macros")
    find_package(CUDAToolkit REQUIRED)
    target_link_libraries(yakl CUDA::cufft)
  else()
    target_link_libraries(yakl cufft)
  endif()
  if (${CMAKE_VERSION} VERSION_GREATER_EQUAL 3.18)
    set_property(TARGET yakl PROPERTY CUDA_ARCHITECTURES OFF)
  endif()
endif()

if ("${YAKL_ARCH}" STREQUAL "HIP")
  target_link_libraries(yakl roctx64 rocfft)
endif()

if ("${YAKL_ARCH}" STREQUAL "SYCL")
  target_link_libraries(yakl "${YAKL_COMPILER_FLAGS}")
endif()

if ("${YAKL_ARCH}" STREQUAL "OPENMP45")
  target_link_libraries(yakl "${YAKL_OPENMP45_FLAGS}")
endif()

if ("${YAKL_ARCH}" STREQUAL "OPENMP")
  target_link_libraries(yakl "${YAKL_OPENMP_FLAGS}")
endif()

#
# Generate configs files
#

include(CMakePackageConfigHelpers)

# setup some variables
set(version_config ${PROJECT_BINARY_DIR}/yakl-config-version.cmake)
set(project_config_src ${PROJECT_SOURCE_DIR}/src/yakl-config.cmake.in)
set(project_config_dst ${PROJECT_BINARY_DIR}/src/yakl-config.cmake)
set(targets_export_name yakl-targets)

set(INSTALL_LIBDIR ${CMAKE_INSTALL_LIBDIR} CACHE STRING
  "Installation directory for libraries, relative to ${CMAKE_INSTALL_PREFIX}.")

set(INSTALL_INCLUDEDIR ${CMAKE_INSTALL_INCLUDEDIR} CACHE STRING
  "Installation directory for include files, relative to ${CMAKE_INSTALL_PREFIX}.")

set(INSTALL_PKGCONFIG_DIR ${CMAKE_INSTALL_LIBDIR}/pkgconfig CACHE PATH
  "Installation directory for pkgconfig (.pc) files, relative to ${CMAKE_INSTALL_PREFIX}.")

set(INSTALL_CMAKE_DIR ${CMAKE_INSTALL_LIBDIR}/cmake CACHE STRING
  "Installation directory for cmake files, relative to ${CMAKE_INSTALL_PREFIX}.")

# Generate the version, config and target files into the build directory.
write_basic_package_version_file(
  ${version_config}
  VERSION ${PROJECT_VERSION}
  COMPATIBILITY AnyNewerVersion)

# generate cmake my_package-config.cmake file
configure_package_config_file(
  ${project_config_src}
  ${project_config_dst}
  INSTALL_DESTINATION ${INSTALL_CMAKE_DIR})

#
# setup the list of targets to install
#
set (INSTALL_TARGETS yakl)

# Use a namespace because CMake provides better diagnostics
# for namespaced imported targets.
export(
  TARGETS ${INSTALL_TARGETS} NAMESPACE yakl::
  FILE ${PROJECT_BINARY_DIR}/${targets_export_name}.cmake)

#
# Install cmake config and target files.
#
install(
  FILES ${project_config_dst} ${version_config}
  DESTINATION ${INSTALL_CMAKE_DIR})

install(
  EXPORT ${targets_export_name}
  DESTINATION ${INSTALL_CMAKE_DIR}
  NAMESPACE yakl::)

#
# install libyakl
#
install(
  TARGETS yakl
  EXPORT ${targets_export_name}
  LIBRARY DESTINATION ${INSTALL_LIBDIR}
  ARCHIVE DESTINATION ${INSTALL_LIBDIR}
  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
install(DIRECTORY src/ external/ DESTINATION include FILES_MATCHING PATTERN "*.h")
install(FILES ${CMAKE_CURRENT_BINARY_DIR}/gator_mod.mod DESTINATION include)
install(CODE "file(WRITE ${CMAKE_INSTALL_PREFIX}/yakl_variables.cmake \"set(YAKL_COMPILER_FLAGS \\\"${YAKL_COMPILER_FLAGS}\\\")\nset(YAKL_ARCH \\\"${YAKL_ARCH}\\\")\n\")" )
install(CODE "file(WRITE ${CMAKE_INSTALL_PREFIX}/yakl_variables.make \"YAKL_COMPILER_FLAGS := ${YAKL_COMPILER_FLAGS}\nYAKL_ARCH := ${YAKL_ARCH}\n\")" )
